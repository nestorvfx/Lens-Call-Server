<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Mesh Tracking & Data Streaming</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #f8f9fa;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        .video-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #inputVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
            object-position: center;
            background: #000;
            transform: scaleX(-1);
        }

        #outputCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
            font-size: 18px;
            font-weight: 400;
            z-index: 10;
            text-align: center;
            background: rgba(255, 255, 255, 0.9);
            padding: 20px 30px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
        }

        .loading::after {
            content: '';
            display: block;
            width: 30px;
            height: 30px;
            margin: 15px auto 0;
            border: 2px solid #e3e3e3;
            border-top: 2px solid #333;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #d32f2f;
            font-size: 16px;
            text-align: center;
            z-index: 10;
            padding: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid #ffcdd2;
        }

        .mouth-meter {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-family: 'Segoe UI', monospace;
            font-size: 14px;
            z-index: 4;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: none; /* Hidden by default */
        }

        /* WebSocket Connection Panel */
        .websocket-panel {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 25px 30px;
            border-radius: 10px;
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
            z-index: 5;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 320px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.37);
        }

        .websocket-panel h3 {
            margin: 0 0 15px 0;
            color: #FFC107;
            font-size: 18px;
            text-align: center;
        }

        .session-input {
            width: 100%;
            padding: 12px 15px;
            margin: 10px 0;
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            font-size: 18px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-align: center;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            outline: none;
            transition: border-color 0.3s;
        }
        .session-input:focus {
            border-color: #FFC107;
        }

        .connect-btn {
            width: 100%;
            padding: 12px;
            margin-top: 5px;
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .connect-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .connect-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .connection-status {
            padding: 8px;
            margin-top: 15px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .status-disconnected {
            background: rgba(244, 67, 54, 0.3);
            border: 1px solid #f44336;
        }
        .status-connected {
            background: rgba(76, 175, 80, 0.3);
            border: 1px solid #4CAF50;
        }
        .status-connecting {
            background: rgba(255, 193, 7, 0.3);
            border: 1px solid #FFC107;
        }
        .status-error {
             background: rgba(244, 67, 54, 0.5);
             border: 1px solid #f44336;
        }

        .websocket-info {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            margin-top: 15px;
            line-height: 1.4;
            text-align: center;
        }

        .mouth-bar {
            width: 120px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }

        .mouth-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
            border-radius: 4px;
            transition: width 0.1s ease;
            width: 0%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="video-container">
            <video id="inputVideo" autoplay muted playsinline></video>
            <canvas id="outputCanvas"></canvas>
            <div class="loading" id="loading">
                Initializing Face Mesh...
            </div>
            <div class="mouth-meter" id="mouthMeter">
                <div>Mouth Opening</div>
                <div class="mouth-bar">
                    <div class="mouth-fill" id="mouthFill"></div>
                </div>
                <div id="mouthText">0%</div>
            </div>
            
            <!-- WebSocket Connection Panel -->
            <div class="websocket-panel" id="websocketPanel">
                <h3>ðŸ”— Lens Studio Connection</h3>
                <div class="websocket-info">
                    Enter the 7-character code from the Lens Studio console to stream mouth data.
                </div>
                <input type="text" 
                       id="sessionCodeInput" 
                       class="session-input" 
                       placeholder="A1B2C3D"
                       maxlength="7">
                <button id="connectBtn" class="connect-btn">Connect to Session</button>
                <div id="connectionStatus" class="connection-status status-disconnected">
                    Disconnected
                </div>
            </div>
        </div>
    </div>

    <!-- Official MediaPipe Tasks Vision -->
    <script type="module">
        import { FaceLandmarker, FilesetResolver } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest';
        window.FaceLandmarker = FaceLandmarker;
        window.FilesetResolver = FilesetResolver;

        // --- WebSocket Integration Module ---
        // This module is now integrated directly below for simplicity.
    </script>
    
    <script>
        const videoElement = document.getElementById('inputVideo');
        const canvasElement = document.getElementById('outputCanvas');
        const canvasCtx = canvasElement.getContext('2d');
        const loadingElement = document.getElementById('loading');
        
        // UI Elements
        const mouthMeter = document.getElementById('mouthMeter');
        const mouthFill = document.getElementById('mouthFill');
        const mouthText = document.getElementById('mouthText');
        const websocketPanel = document.getElementById('websocketPanel');
        const sessionCodeInput = document.getElementById('sessionCodeInput');
        const connectBtn = document.getElementById('connectBtn');
        const connectionStatus = document.getElementById('connectionStatus');

        let faceLandmarker = undefined;
        let runningMode = "VIDEO";
        let webcamRunning = false;
        
        // WebSocket State
        let socket = null;
        let isConnected = false;
        let sevenCharCode = '';
        const SERVER_URL = 'ws://localhost:3000'; // Change if your server is hosted elsewhere

        // ========================================
        // MediaPipe Initialization & Logic
        // ========================================

        const createFaceLandmarker = async () => {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
            );
            
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task`,
                    delegate: "GPU"
                },
                outputFaceBlendshapes: true,
                runningMode: runningMode,
                numFaces: 1
            });
            console.log("Face Landmarker loaded");
        };

        const enableCam = async () => {
            if (!faceLandmarker) {
                console.log("Wait! Face Landmarker not loaded yet.");
                return;
            }
            webcamRunning = true;
            const stream = await navigator.mediaDevices.getUserMedia({ video: true });
            videoElement.srcObject = stream;
            videoElement.addEventListener("loadeddata", predictWebcam);
        };

        let lastVideoTime = -1;
        function predictWebcam() {
            if (runningMode === "IMAGE") {
                runningMode = "VIDEO";
                faceLandmarker.setOptions({ runningMode: "VIDEO" });
            }
            let startTimeMs = performance.now();
            if (videoElement.currentTime !== lastVideoTime) {
                lastVideoTime = videoElement.currentTime;
                const results = faceLandmarker.detectForVideo(videoElement, startTimeMs);
                
                if (results.faceLandmarks && results.faceLandmarks.length > 0) {
                    const mouthOpenRatio = calculateMouthOpenRatio(results.faceLandmarks[0]);
                    updateMouthMeter(mouthOpenRatio);
                    
                    // If connected, stream data to the server
                    if (isConnected && socket && socket.readyState === WebSocket.OPEN) {
                        socket.send(JSON.stringify({
                            type: 'mouth_data',
                            sevenCharCode: sevenCharCode,
                            mouthOpenness: mouthOpenRatio
                        }));
                    }
                }
            }

            if (webcamRunning === true) {
                window.requestAnimationFrame(predictWebcam);
            }
        }

        function calculateMouthOpenRatio(landmarks) {
            const upperLipTop = landmarks[13];
            const lowerLipBottom = landmarks[14];
            const leftMouthCorner = landmarks[61];
            const rightMouthCorner = landmarks[291];
            
            if (!upperLipTop || !lowerLipBottom || !leftMouthCorner || !rightMouthCorner) return 0;
            
            const verticalDistance = Math.abs(lowerLipBottom.y - upperLipTop.y);
            const horizontalDistance = Math.abs(rightMouthCorner.x - leftMouthCorner.x);
            
            if (horizontalDistance === 0) return 0;
            
            const ratio = verticalDistance / horizontalDistance;
            
            const minRatio = 0.05; // Calibrated threshold for a closed mouth
            const maxRatio = 0.8;  // Calibrated threshold for a wide-open mouth
            
            if (ratio <= minRatio) return 0;
            if (ratio >= maxRatio) return 1;
            return (ratio - minRatio) / (maxRatio - minRatio);
        }

        function updateMouthMeter(ratio) {
            const percentage = Math.round(ratio * 100);
            mouthFill.style.width = `${percentage}%`;
            mouthText.textContent = `${percentage}%`;
        }
        
        // ========================================
        // WebSocket Integration & UI Logic
        // ========================================
        
        function connectToServer() {
            const code = sessionCodeInput.value.trim().toUpperCase();
            if (code.length !== 7) {
                alert('Please enter a valid 7-character code.');
                return;
            }
            sevenCharCode = code;

            setConnectionStatus('connecting', 'Connecting...');
            connectBtn.disabled = true;

            socket = new WebSocket(SERVER_URL);

            socket.onopen = () => {
                console.log('WebSocket connection opened.');
                // Identify this web client to the server
                socket.send(JSON.stringify({ type: 'web_app_connect', sevenCharCode }));
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('Message from server:', data);
                
                switch(data.type) {
                    case 'connection_successful':
                        isConnected = true;
                        setConnectionStatus('connected', 'Connected');
                        // Transition UI
                        websocketPanel.style.display = 'none';
                        mouthMeter.style.display = 'block';
                        break;
                    case 'error':
                        setConnectionStatus('error', `Error: ${data.message}`);
                        socket.close(); // Close the socket on error
                        break;
                }
            };

            socket.onclose = () => {
                console.log('WebSocket connection closed.');
                isConnected = false;
                setConnectionStatus('disconnected', 'Disconnected');
                connectBtn.disabled = false;
                sessionCodeInput.disabled = false;
                // Transition UI back
                websocketPanel.style.display = 'block';
                mouthMeter.style.display = 'none';
            };

            socket.onerror = (error) => {
                console.error('WebSocket Error:', error);
                setConnectionStatus('error', 'Connection Failed');
                connectBtn.disabled = false;
                sessionCodeInput.disabled = false;
            };
        }

        function setConnectionStatus(status, text) {
            connectionStatus.textContent = text;
            connectionStatus.className = 'connection-status'; // Reset classes
            connectionStatus.classList.add(`status-${status}`);
        }

        // ========================================
        // Main Initialization
        // ========================================

        async function init() {
            try {
                // Wait for MediaPipe modules to be available on the window object
                while (!window.FaceLandmarker || !window.FilesetResolver) {
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                loadingElement.innerHTML = "Loading MediaPipe Model...";
                await createFaceLandmarker();
                
                loadingElement.innerHTML = "Requesting Camera Access...";
                await enableCam();
                
                videoElement.addEventListener('loadeddata', () => {
                    loadingElement.style.display = 'none';
                    websocketPanel.style.display = 'block'; // Show connection panel after loading
                });
                
                // Set up event listeners
                connectBtn.addEventListener('click', connectToServer);

            } catch (error) {
                console.error('Initialization Error:', error);
                loadingElement.style.display = 'none'; // Hide loading spinner
                 document.body.innerHTML = `
                    <div class="error">
                        <strong>Initialization Error</strong><br>
                        Could not access camera or load models. Please check permissions and refresh.<br>
                        <small>${error.message}</small>
                    </div>
                `;
            }
        }

        // Start when the page loads
        window.addEventListener('load', init);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (socket) socket.close();
            if (videoElement.srcObject) {
                videoElement.srcObject.getTracks().forEach(track => track.stop());
            }
        });

    </script>
</body>
</html>